using KernelDensity
using PyPlot

# This script relies on data (emu_out, sim_out) that is generated by running smc-abc-script.jl

function plot_emulation_vs_simulation(emu_out, sim_out)
            grid_size = emu_out.n_params
            emu_handle = nothing
            sim_handle = nothing
            kernel_bandwidth_scale = 0.09
            bounds_scale = 1.2
            for i in 1:grid_size
                for j in 1:grid_size
                    if j < i
                        subplot2grid((grid_size, grid_size), (i - 1, j - 1))

                        x_data_emu = emu_out.population[end][:,i]
                        y_data_emu = emu_out.population[end][:,j]
                        x_data_sim = sim_out.population[end][:,i]
                        y_data_sim = sim_out.population[end][:,j]
                        x_extr_emu = extrema(x_data_emu)
                        y_extr_emu = extrema(y_data_emu)
                        x_extr_sim = extrema(x_data_sim)
                        y_extr_sim = extrema(y_data_sim)

                        x_min = min(x_extr_emu[1], x_extr_sim[1])
                        x_max = max(x_extr_emu[2], x_extr_sim[2])
                        x_mid = (x_min + x_max) / 2
                        x_diff = (x_max - x_min) / 2
                        x_bounds =  (-x_diff, x_diff) .* bounds_scale .+ x_mid
                        y_min = min(y_extr_emu[1], y_extr_sim[1]) * 0.9
                        y_max = max(y_extr_emu[2], y_extr_sim[2]) * 1.1
                        y_mid = (y_min + y_max) / 2
                        y_diff = (y_max - y_min) / 2
                        y_bounds =  (-y_diff, y_diff) .* bounds_scale .+ y_mid
                        xlim(x_bounds)
                        ylim(y_bounds)

                        bandwidth = (-kernel_bandwidth_scale * -(x_extr_emu...), -kernel_bandwidth_scale * -(y_extr_emu...))
                        kde_joint = kde(hcat(x_data_emu, y_data_emu), bandwidth=bandwidth)
                        contour_x = linspace(x_bounds..., 100)
                        contour_y = linspace(y_bounds..., 100)
                        contour_z = pdf(kde_joint, contour_x, contour_y)
                        # contour(contour_x, contour_y, contour_z, 8,
                        #             colors=["#FFE9EC", "#FFE9EC", "#FFBBC5", "#FF8B9C", "#FF5D75", "#FF2F4E", "#D0001F", "#A20018"],
                        #             zorder=1)
                        contourf(contour_x, contour_y, contour_z, 8,
                                    colors=["white", "#FFE9EC", "#FFBBC5", "#FF8B9C", "#FF5D75", "#FF2F4E", "#D0001F", "#A20018",  "#A20018"],
                                    zorder=1)

                        scatter(x_data_sim, y_data_sim, marker="x", color="cornflowerblue", zorder=2)
                        # xlabel("Parameter $i")
                        # ylabel("Parameter $j")
                    elseif i == j
                        subplot2grid((grid_size, grid_size), (i - 1, j - 1))
                        emu_data = emu_out.population[end][:,i]
                        sim_data = sim_out.population[end][:,i]
                        extr_emu = extrema(emu_data)
                        extr_sim = extrema(sim_data)
                        kde_emu = kde(emu_data, bandwidth=-kernel_bandwidth_scale * -(extr_emu...))
                        kde_sim = kde(sim_data, bandwidth=-kernel_bandwidth_scale * -(extr_sim...))
                        x_min = min(extr_emu[1], extr_sim[1])
                        x_max = max(extr_emu[2], extr_sim[2])
                        x_mid = (x_min + x_max) / 2
                        x_diff = (x_max - x_min) / 2
                        x_bounds = (-x_diff, x_diff) .* bounds_scale .+ x_mid
                        xlim(x_bounds)
                        x_plot = linspace(x_bounds..., 100)
                        y_emu_plot = pdf(kde_emu,x_plot)
                        y_sim_plot = pdf(kde_sim,x_plot)
                        emu_handle = plot(x_plot, y_emu_plot, color="#ff6600")
                        sim_handle = plot(x_plot, y_sim_plot, color="cornflowerblue")
                        # xlabel("Parameter $i")
                        # yticks([])
                    end
                end
            end
            # if grid_size > 1
            #     subplot2grid((grid_size, grid_size), (0, 1))
            #     legend([emu_handle; sim_handle], ["Emulation", "Simulation"], loc="upper left")
            #     axis("off")
            # else
                figlegend([emu_handle; sim_handle], ["Emulation", "Simulation"], loc="upper right")
            # end
end

sim_out1 = GpABC.SimulatedABCSMCOutput(sim_out.n_params, sim_out.n_accepted,
                        sim_out.n_tries, sim_out.threshold_schedule[1:end-1],
                        sim_out.population[1:end-1], sim_out.distances[1:end-1],
                        sim_out.weights[1:end-1])

ion()
fig = figure(figsize=(10,10))
ioff()
plot_emulation_vs_simulation(emu_out, sim_out1)
subplots_adjust(
left    =  0.08,
bottom  =  0.06,
right   =  0.96,
top     =  0.97,
wspace  =  0.26,
hspace  =  0.26)
show(fig)
# savefig("/project/home17/et517/Desktop/gpabc-figure-emu-sim.pdf")
# import Plots
# Plots.pyplot()
# Plots.plot(emu_out, population_colors=["orange", "red", "blue"])
#
# mean, var = gp_regression(emu_out.emulators[1])
# variance_perm = sortperm(var, rev=true)
# var[variance_perm[1:5]]
# mean[variance_perm[1:5]]
# mean[mean .< 1.0]
# var[mean .< 1.0]

figure()
scatter(emu_out_4_6.population[1][:, 1], emu_out_4_6.distances[1], marker=".")

training_y = GpABC.simulate_distance(emu_out_4_6.emulators[1].training_x)

function plot_distances_training_accepted(emu_out::ABCSMCOutput)
    n_iter = length(emu_out.threshold_schedule)
    for smc_iteration in 1:n_iter
        for parameter_idx in 1:emu_out.n_params
            subplot_idx = (smc_iteration - 1) * emu_out.n_params + parameter_idx
            subplot(n_iter, emu_out.n_params, subplot_idx)
            title("SMC iteration $(smc_iteration)")
            scatter(emu_out.emulators[smc_iteration].gp_training_x[:, parameter_idx],
                emu_out.emulators[smc_iteration].gp_training_y, marker=".",
                label="Emulation - training")
            scatter(emu_out.population[smc_iteration][:, parameter_idx],
                emu_out.distances[smc_iteration], marker=".",
                label="Emulation - accepted")
            xlabel("Theta_$(parameter_idx)")
            ylabel("SMC iteration $(smc_iteration) - L2 distance")
            legend()
        end
    end
end

ion()
f = figure()
ioff()
plot_distances_training_accepted(emu_out)
subplots_adjust(
left    =  0.08,
bottom  =  0.06,
right   =  0.96,
top     =  0.97,
wspace  =  0.26,
hspace  =  0.3
)
show(f)

import Plots
Plots.pyplot()
Plots.plot(emu_out_4_6_1)
Plots.gui()
